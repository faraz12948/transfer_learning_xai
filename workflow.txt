This code is a PyTorch-based pipeline for classifying Alzheimer’s MRI images using transfer learning with multiple model configurations.
Here’s the step-by-step workflow:

1. Setup and Imports
The code imports:

Data handling: numpy, pandas, os, cv2, sklearn

Visualization: matplotlib, seaborn

Deep learning: torch, torchvision

Progress bars: tqdm


2. Device Selection
python
Copy
Edit
DEVICE = torch.device("cuda" if torch.cuda.is_available() else "cpu")
Checks if CUDA GPU is available → use it.

Otherwise, uses CPU.

All tensors and models will be moved to this device.


3. Dataset Loading
python
Copy
Edit
data_path = "./dataset/OriginalDataset"
labels = ['MildDemented', 'ModerateDemented', 'NonDemented', 'VeryMildDemented']
The dataset is organized into folders, each representing a class.

Reads images from these folders, resizes to 170×170, stores them in:

X: image data (numpy array)

y: class labels (strings)

4. Data Preview
Plots 4 random images from each class for visual inspection.

5. Data Preprocessing
Shuffle the dataset (random order).

Split into training (90%) and testing (10%) using train_test_split.

Label Encoding: Converts string labels into numeric IDs for PyTorch.

6. Custom Dataset Class
python
Copy
Edit
class AlzheimerDataset(Dataset):
    ...
Converts images and labels into a PyTorch-friendly format.

Applies transformations:

Convert to PIL image.

Resize → Tensor → Normalize.

7. Datasets and Dataloaders
python
Copy
Edit
train_dataset = AlzheimerDataset(X_train, y_train_idx, transform=transform)
test_dataset = AlzheimerDataset(X_test, y_test_idx, transform=transform)
Wraps training and testing data in Dataset objects.

DataLoader handles batching and shuffling for training.


8. Model Configurations
python
Copy
Edit
configs = { ... }
Three experiments (deepseek_code_7b, Random_Search, Bayesian_Opt).

Each has:

Model architecture (efficientnet_b0, densenet121)

Learning rate

Batch size

Dropout rate

Dense layer size

Which layers to train (all, last_n, or none).


9. Transfer Learning
For each configuration:

Load pre-trained model (IMAGENET1K_V1 weights).

Freeze some layers based on trainable_layers setting.

Replace classifier with:

nginx
Copy
Edit
Linear → BatchNorm → ReLU → Dropout → Linear
where the output size matches the number of classes.

10. Training Loop
For 12 epochs:

Forward pass

Compute loss (CrossEntropyLoss)

Backward pass

Update weights (Adam or SGD)

Track loss & accuracy per epoch


11. Evaluation
After training:

Switch model to eval() mode.

Predict labels on the test set.

Generate:

Classification report (precision, recall, F1-score).

Confusion matrix heatmap.

12. Summary
Workflow in plain language:

Load Alzheimer MRI images from folders.

Preprocess (resize, normalize, encode labels).

Set up PyTorch datasets/dataloaders.

Define multiple model configurations.

For each configuration:

Load a pre-trained CNN (EfficientNet or DenseNet).

Modify its classifier for our dataset.

Train it on the training set.

Evaluate on the test set.

Show accuracy, detailed metrics, and a confusion matrix.